<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.6.3" />
<title>logger.listener.listener API documentation</title>
<meta name="description" content="" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase;cursor:pointer}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>logger.listener.listener</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>Source code</summary>
<pre><code class="python">#!/usr/bin/env python3

import logging
import logging.handlers
import sys
import time
import traceback

from os import makedirs
from os.path import dirname, realpath; sys.path.append(dirname(dirname(dirname(realpath(__file__)))))

from logger.readers.composed_reader import ComposedReader
from logger.writers.composed_writer import ComposedWriter
from logger.utils.stderr_logging import setUpStdErrLogging, StdErrLoggingHandler

    
################################################################################
class Listener:
  &#34;&#34;&#34;Listener is a simple, yet relatively self-contained class that
  takes a list of one or more Readers, a list of zero or more
  Transforms, and a list of zero or more Writers. It calls the Readers
  (in parallel) to acquire records, passes those records through the
  Transforms (in series), and sends the resulting records to the Writers
  (in parallel).

  &#34;&#34;&#34;
  ############################
  def __init__(self, readers, transforms=[], writers=[], stderr_writers=[],
               host_id=&#39;&#39;, interval=0, name=None, check_format=False,
               log_level=None):
    &#34;&#34;&#34;listener = Listener(readers, transforms=[], writers=[],
                        interval=0, check_format=False)

    readers        A single Reader or a list of Readers.

    transforms     A single Transform or a list of zero or more Transforms

    writers        A single Writer or a list of zero or more Writers

    stderr_writers A single Writer or a list of zero or more Writers to which
                   the logger&#39;s stderr should be written.

    host_id        Optional host_id on which Listener is to be run. Ignored
                   here, but it may show up as part of a config, so we need
                   to be able to handle is in kwargs.

    interval       How long to sleep before reading sequential records

    name           Optional human-readable short name to be used in displays

    check_format   If True, attempt to check that Reader/Transform/Writer
                   formats are compatible, and throw a ValueError if they
                   are not. If check_format is False (the default) the
                   output_format() of the whole reader will be
                   formats.Unknown.

    Sample use:

    listener = Listener(readers=[NetworkReader(&#39;:6221&#39;),
                                 NetworkReader(&#39;:6223&#39;)],
                        transforms=[TimestampTransform()],
                        writers=[TextFileWriter(&#39;/logs/network_recs&#39;),
                                 TextFileWriter(None)],
                        interval=0.2)
    listener.run()

    Calling listener.quit() from another thread will cause the run() loop
    to exit.
    &#34;&#34;&#34;
    # Set up logging first of all
    setUpStdErrLogging(log_level=log_level)
    if stderr_writers:
      logging.getLogger().addHandler(StdErrLoggingHandler(stderr_writers))

    logging.info(&#39;Instantiating %s logger&#39;, name or &#39;unnamed&#39;)
    
    ###########
    # Create readers, writers, etc.
    self.reader = ComposedReader(readers=readers, check_format=check_format)
    self.writer = ComposedWriter(transforms=transforms, writers=writers,
                                 check_format=check_format)
    self.interval = interval
    self.name = name or &#39;Unnamed listener&#39;
    self.last_read = 0

    self.quit_signalled = False

  ############################
  def quit(self):
    &#34;&#34;&#34;
    Signal &#39;quit&#39; to all the readers.
    &#34;&#34;&#34;
    self.quit_signalled = True
    logging.info(&#39;Shutting down %s&#39;, self.name)

  ############################
  def run(self):
    &#34;&#34;&#34;
    Read/transform/write until either quit() is called in a separate
    thread, or ComposedReader returns None, indicating that all its
    component readers have returned EOF.
    &#34;&#34;&#34;
    logging.info(&#39;Running %s&#39;, self.name)
    record = &#39;&#39;
    try:
      while not self.quit_signalled and record is not None:
        record = self.reader.read()
        self.last_read = time.time()
        logging.debug(&#39;ComposedReader read: &#34;%s&#34;&#39;, record)
        if record:
          self.writer.write(record)

        if self.interval:
          time_to_sleep = self.interval - (time.time() - self.last_read)
          time.sleep(max(time_to_sleep, 0))

    # Exit in an orderly fashion if someone hits Ctl-C
    except KeyboardInterrupt:
      logging.info(&#39;Listener %s received KeyboardInterrupt - exiting.&#39;,
                   self.name or &#39;&#39;)
    except Exception as e:
      logging.info(&#39;Listener %s received exception: %s&#39;,
                   self.name, traceback.format_exc())
      raise e</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="logger.listener.listener.Listener"><code class="flex name class">
<span>class <span class="ident">Listener</span></span>
<span>(</span><span>readers, transforms=[], writers=[], stderr_writers=[], host_id='', interval=0, name=None, check_format=False, log_level=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Listener is a simple, yet relatively self-contained class that
takes a list of one or more Readers, a list of zero or more
Transforms, and a list of zero or more Writers. It calls the Readers
(in parallel) to acquire records, passes those records through the
Transforms (in series), and sends the resulting records to the Writers
(in parallel).</p>
<p>listener = Listener(readers, transforms=[], writers=[],
interval=0, check_format=False)</p>
<p>readers
A single Reader or a list of Readers.</p>
<p>transforms
A single Transform or a list of zero or more Transforms</p>
<p>writers
A single Writer or a list of zero or more Writers</p>
<p>stderr_writers A single Writer or a list of zero or more Writers to which
the logger's stderr should be written.</p>
<p>host_id
Optional host_id on which Listener is to be run. Ignored
here, but it may show up as part of a config, so we need
to be able to handle is in kwargs.</p>
<p>interval
How long to sleep before reading sequential records</p>
<p>name
Optional human-readable short name to be used in displays</p>
<p>check_format
If True, attempt to check that Reader/Transform/Writer
formats are compatible, and throw a ValueError if they
are not. If check_format is False (the default) the
output_format() of the whole reader will be
formats.Unknown.</p>
<p>Sample use:</p>
<p>listener = Listener(readers=[NetworkReader(':6221'),
NetworkReader(':6223')],
transforms=[TimestampTransform()],
writers=[TextFileWriter('/logs/network_recs'),
TextFileWriter(None)],
interval=0.2)
listener.run()</p>
<p>Calling listener.quit() from another thread will cause the run() loop
to exit.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">class Listener:
  &#34;&#34;&#34;Listener is a simple, yet relatively self-contained class that
  takes a list of one or more Readers, a list of zero or more
  Transforms, and a list of zero or more Writers. It calls the Readers
  (in parallel) to acquire records, passes those records through the
  Transforms (in series), and sends the resulting records to the Writers
  (in parallel).

  &#34;&#34;&#34;
  ############################
  def __init__(self, readers, transforms=[], writers=[], stderr_writers=[],
               host_id=&#39;&#39;, interval=0, name=None, check_format=False,
               log_level=None):
    &#34;&#34;&#34;listener = Listener(readers, transforms=[], writers=[],
                        interval=0, check_format=False)

    readers        A single Reader or a list of Readers.

    transforms     A single Transform or a list of zero or more Transforms

    writers        A single Writer or a list of zero or more Writers

    stderr_writers A single Writer or a list of zero or more Writers to which
                   the logger&#39;s stderr should be written.

    host_id        Optional host_id on which Listener is to be run. Ignored
                   here, but it may show up as part of a config, so we need
                   to be able to handle is in kwargs.

    interval       How long to sleep before reading sequential records

    name           Optional human-readable short name to be used in displays

    check_format   If True, attempt to check that Reader/Transform/Writer
                   formats are compatible, and throw a ValueError if they
                   are not. If check_format is False (the default) the
                   output_format() of the whole reader will be
                   formats.Unknown.

    Sample use:

    listener = Listener(readers=[NetworkReader(&#39;:6221&#39;),
                                 NetworkReader(&#39;:6223&#39;)],
                        transforms=[TimestampTransform()],
                        writers=[TextFileWriter(&#39;/logs/network_recs&#39;),
                                 TextFileWriter(None)],
                        interval=0.2)
    listener.run()

    Calling listener.quit() from another thread will cause the run() loop
    to exit.
    &#34;&#34;&#34;
    # Set up logging first of all
    setUpStdErrLogging(log_level=log_level)
    if stderr_writers:
      logging.getLogger().addHandler(StdErrLoggingHandler(stderr_writers))

    logging.info(&#39;Instantiating %s logger&#39;, name or &#39;unnamed&#39;)
    
    ###########
    # Create readers, writers, etc.
    self.reader = ComposedReader(readers=readers, check_format=check_format)
    self.writer = ComposedWriter(transforms=transforms, writers=writers,
                                 check_format=check_format)
    self.interval = interval
    self.name = name or &#39;Unnamed listener&#39;
    self.last_read = 0

    self.quit_signalled = False

  ############################
  def quit(self):
    &#34;&#34;&#34;
    Signal &#39;quit&#39; to all the readers.
    &#34;&#34;&#34;
    self.quit_signalled = True
    logging.info(&#39;Shutting down %s&#39;, self.name)

  ############################
  def run(self):
    &#34;&#34;&#34;
    Read/transform/write until either quit() is called in a separate
    thread, or ComposedReader returns None, indicating that all its
    component readers have returned EOF.
    &#34;&#34;&#34;
    logging.info(&#39;Running %s&#39;, self.name)
    record = &#39;&#39;
    try:
      while not self.quit_signalled and record is not None:
        record = self.reader.read()
        self.last_read = time.time()
        logging.debug(&#39;ComposedReader read: &#34;%s&#34;&#39;, record)
        if record:
          self.writer.write(record)

        if self.interval:
          time_to_sleep = self.interval - (time.time() - self.last_read)
          time.sleep(max(time_to_sleep, 0))

    # Exit in an orderly fashion if someone hits Ctl-C
    except KeyboardInterrupt:
      logging.info(&#39;Listener %s received KeyboardInterrupt - exiting.&#39;,
                   self.name or &#39;&#39;)
    except Exception as e:
      logging.info(&#39;Listener %s received exception: %s&#39;,
                   self.name, traceback.format_exc())
      raise e</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="logger.listener.listen.ListenerFromLoggerConfig" href="listen.html#logger.listener.listen.ListenerFromLoggerConfig">ListenerFromLoggerConfig</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="logger.listener.listener.Listener.quit"><code class="name flex">
<span>def <span class="ident">quit</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Signal 'quit' to all the readers.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def quit(self):
  &#34;&#34;&#34;
  Signal &#39;quit&#39; to all the readers.
  &#34;&#34;&#34;
  self.quit_signalled = True
  logging.info(&#39;Shutting down %s&#39;, self.name)</code></pre>
</details>
</dd>
<dt id="logger.listener.listener.Listener.run"><code class="name flex">
<span>def <span class="ident">run</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Read/transform/write until either quit() is called in a separate
thread, or ComposedReader returns None, indicating that all its
component readers have returned EOF.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def run(self):
  &#34;&#34;&#34;
  Read/transform/write until either quit() is called in a separate
  thread, or ComposedReader returns None, indicating that all its
  component readers have returned EOF.
  &#34;&#34;&#34;
  logging.info(&#39;Running %s&#39;, self.name)
  record = &#39;&#39;
  try:
    while not self.quit_signalled and record is not None:
      record = self.reader.read()
      self.last_read = time.time()
      logging.debug(&#39;ComposedReader read: &#34;%s&#34;&#39;, record)
      if record:
        self.writer.write(record)

      if self.interval:
        time_to_sleep = self.interval - (time.time() - self.last_read)
        time.sleep(max(time_to_sleep, 0))

  # Exit in an orderly fashion if someone hits Ctl-C
  except KeyboardInterrupt:
    logging.info(&#39;Listener %s received KeyboardInterrupt - exiting.&#39;,
                 self.name or &#39;&#39;)
  except Exception as e:
    logging.info(&#39;Listener %s received exception: %s&#39;,
                 self.name, traceback.format_exc())
    raise e</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="logger.listener" href="index.html">logger.listener</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="logger.listener.listener.Listener" href="#logger.listener.listener.Listener">Listener</a></code></h4>
<ul class="">
<li><code><a title="logger.listener.listener.Listener.quit" href="#logger.listener.listener.Listener.quit">quit</a></code></li>
<li><code><a title="logger.listener.listener.Listener.run" href="#logger.listener.listener.Listener.run">run</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.6.3</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>