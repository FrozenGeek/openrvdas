<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.6.3" />
<title>logger.writers.udp_writer API documentation</title>
<meta name="description" content="" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase;cursor:pointer}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>logger.writers.udp_writer</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>Source code</summary>
<pre><code class="python">#!/usr/bin/env python3

import json
import ipaddress
import logging
import socket
import struct
import sys

from os.path import dirname, realpath; sys.path.append(dirname(dirname(dirname(realpath(__file__)))))

from logger.utils.formats import Text
from logger.utils.das_record import DASRecord
from logger.writers.network_writer import NetworkWriter

################################################################################
class UDPWriter(NetworkWriter):
  &#34;&#34;&#34;Write UDP packets to network.&#34;&#34;&#34;
  def __init__(self, port, destination=&#39;&#39;, interface=&#39;&#39;,
               ttl=3, num_retry=2, eol=&#39;&#39;):
    &#34;&#34;&#34;
    Write text records to a network socket.
    ```
    port         Port to which packets should be sent

    destination  If specified, either multicast group or unicast IP addr

    interface    If specified, the network interface to send from

    ttl          For multicast, how many network hops to allow

    num_retry    Number of times to retry if write fails.

    eol          If specified, an end of line string to append to record
                 before sending.
    ```
    &#34;&#34;&#34;
    self.num_retry = num_retry
    self.eol = eol

    self.socket = socket.socket(family=socket.AF_INET,
                                type=socket.SOCK_DGRAM,
                                proto=socket.IPPROTO_UDP)
    self.socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, True)
    try: # Raspbian doesn&#39;t recognize SO_REUSEPORT
      self.socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEPORT, True)
    except AttributeError:
      logging.warning(&#39;Unable to set socket REUSEPORT; may be unsupported&#39;)

    # Set the time-to-live for messages, in case of multicast
    self.socket.setsockopt(socket.IPPROTO_IP, socket.IP_MULTICAST_TTL,
                           struct.pack(&#39;b&#39;, ttl))
    self.socket.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, True)

    if interface and destination:
      ipaddress.ip_address(interface) # throw a ValueError if bad addr
      ipaddress.ip_address(destination)
      # At the moment, we don&#39;t know how to do both interface and
      # multicast/unicast. If they&#39;ve specified both, then complain
      # and ignore the interface part.
      logging.warning(&#39;UDPWriter doesn\&#39;t yet support specifying both &#39;
                      &#39;interface and destination. Ignoring interface &#39;
                      &#39;specification.&#39;)

    # If they&#39;ve specified the interface we&#39;re supposed to be sending
    # via, then we have to do a little legerdemain: we&#39;re going to
    # connect to the broadcast address of the specified interface as
    # our destination. The broadcast address is just the normal
    # address with the last tuple replaced by &#34;.255&#34;.
    elif interface:
      if interface == &#39;0.0.0.0&#39;:  # local network
        destination = &#39;255.255.255.255&#39;
      elif interface in [&#39;&lt;broadcast&gt;&#39;, &#39;None&#39;]:
        destination = &#39;&lt;broadcast&gt;&#39;
      else:
        # Change interface&#39;s lowest tuple to &#39;broadcast&#39; value (255)
        ipaddress.ip_address(interface)
        destination = interface[:interface.rfind(&#39;.&#39;)] + &#39;.255&#39;

    # If we&#39;ve been given a destination, make sure it&#39;s a valid IP
    elif destination:
      ipaddress.ip_address(destination)

    # If no destination, it&#39;s a broadcast; set flag allowing broadcast and
    # set dest to special string
    else:
      destination = &#39;&lt;broadcast&gt;&#39;

    self.socket.connect((destination, port))

  ############################
  def write(self, record):
    &#34;&#34;&#34;Write the record to the network.&#34;&#34;&#34;
    if not record:
      return

    # If record is not a string, try converting to JSON. If we don&#39;t know
    # how, throw a hail Mary and force it into str format
    if not type(record) is str:
      if type(record) in [int, float, bool, list, dict]:
        record = json.dumps(record)
      elif type(record) is DASRecord:
        record = record.as_json()
      else:
        record = str(record)
    if self.eol:
      record += self.eol

    num_tries = 0
    bytes_sent = 0
    rec_len = len(record)
    while num_tries &lt; self.num_retry and bytes_sent &lt; rec_len:
      bytes_sent = self.socket.send(record.encode(&#39;utf-8&#39;))
      num_tries += 1

    logging.debug(&#39;UDPWriter.write() wrote %d/%d bytes after %d tries&#39;,
                    bytes_sent, rec_len, num_tries)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="logger.writers.udp_writer.UDPWriter"><code class="flex name class">
<span>class <span class="ident">UDPWriter</span></span>
<span>(</span><span>port, destination='', interface='', ttl=3, num_retry=2, eol='')</span>
</code></dt>
<dd>
<section class="desc"><p>Write UDP packets to network.</p>
<p>Write text records to a network socket.</p>
<pre><code>port         Port to which packets should be sent

destination  If specified, either multicast group or unicast IP addr

interface    If specified, the network interface to send from

ttl          For multicast, how many network hops to allow

num_retry    Number of times to retry if write fails.

eol          If specified, an end of line string to append to record
             before sending.
</code></pre></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">class UDPWriter(NetworkWriter):
  &#34;&#34;&#34;Write UDP packets to network.&#34;&#34;&#34;
  def __init__(self, port, destination=&#39;&#39;, interface=&#39;&#39;,
               ttl=3, num_retry=2, eol=&#39;&#39;):
    &#34;&#34;&#34;
    Write text records to a network socket.
    ```
    port         Port to which packets should be sent

    destination  If specified, either multicast group or unicast IP addr

    interface    If specified, the network interface to send from

    ttl          For multicast, how many network hops to allow

    num_retry    Number of times to retry if write fails.

    eol          If specified, an end of line string to append to record
                 before sending.
    ```
    &#34;&#34;&#34;
    self.num_retry = num_retry
    self.eol = eol

    self.socket = socket.socket(family=socket.AF_INET,
                                type=socket.SOCK_DGRAM,
                                proto=socket.IPPROTO_UDP)
    self.socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, True)
    try: # Raspbian doesn&#39;t recognize SO_REUSEPORT
      self.socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEPORT, True)
    except AttributeError:
      logging.warning(&#39;Unable to set socket REUSEPORT; may be unsupported&#39;)

    # Set the time-to-live for messages, in case of multicast
    self.socket.setsockopt(socket.IPPROTO_IP, socket.IP_MULTICAST_TTL,
                           struct.pack(&#39;b&#39;, ttl))
    self.socket.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, True)

    if interface and destination:
      ipaddress.ip_address(interface) # throw a ValueError if bad addr
      ipaddress.ip_address(destination)
      # At the moment, we don&#39;t know how to do both interface and
      # multicast/unicast. If they&#39;ve specified both, then complain
      # and ignore the interface part.
      logging.warning(&#39;UDPWriter doesn\&#39;t yet support specifying both &#39;
                      &#39;interface and destination. Ignoring interface &#39;
                      &#39;specification.&#39;)

    # If they&#39;ve specified the interface we&#39;re supposed to be sending
    # via, then we have to do a little legerdemain: we&#39;re going to
    # connect to the broadcast address of the specified interface as
    # our destination. The broadcast address is just the normal
    # address with the last tuple replaced by &#34;.255&#34;.
    elif interface:
      if interface == &#39;0.0.0.0&#39;:  # local network
        destination = &#39;255.255.255.255&#39;
      elif interface in [&#39;&lt;broadcast&gt;&#39;, &#39;None&#39;]:
        destination = &#39;&lt;broadcast&gt;&#39;
      else:
        # Change interface&#39;s lowest tuple to &#39;broadcast&#39; value (255)
        ipaddress.ip_address(interface)
        destination = interface[:interface.rfind(&#39;.&#39;)] + &#39;.255&#39;

    # If we&#39;ve been given a destination, make sure it&#39;s a valid IP
    elif destination:
      ipaddress.ip_address(destination)

    # If no destination, it&#39;s a broadcast; set flag allowing broadcast and
    # set dest to special string
    else:
      destination = &#39;&lt;broadcast&gt;&#39;

    self.socket.connect((destination, port))

  ############################
  def write(self, record):
    &#34;&#34;&#34;Write the record to the network.&#34;&#34;&#34;
    if not record:
      return

    # If record is not a string, try converting to JSON. If we don&#39;t know
    # how, throw a hail Mary and force it into str format
    if not type(record) is str:
      if type(record) in [int, float, bool, list, dict]:
        record = json.dumps(record)
      elif type(record) is DASRecord:
        record = record.as_json()
      else:
        record = str(record)
    if self.eol:
      record += self.eol

    num_tries = 0
    bytes_sent = 0
    rec_len = len(record)
    while num_tries &lt; self.num_retry and bytes_sent &lt; rec_len:
      bytes_sent = self.socket.send(record.encode(&#39;utf-8&#39;))
      num_tries += 1

    logging.debug(&#39;UDPWriter.write() wrote %d/%d bytes after %d tries&#39;,
                    bytes_sent, rec_len, num_tries)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="logger.writers.network_writer.NetworkWriter" href="network_writer.html#logger.writers.network_writer.NetworkWriter">NetworkWriter</a></li>
<li><a title="logger.writers.writer.Writer" href="writer.html#logger.writers.writer.Writer">Writer</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="logger.writers.network_writer.NetworkWriter" href="network_writer.html#logger.writers.network_writer.NetworkWriter">NetworkWriter</a></b></code>:
<ul class="hlist">
<li><code><a title="logger.writers.network_writer.NetworkWriter.can_accept" href="writer.html#logger.writers.writer.Writer.can_accept">can_accept</a></code></li>
<li><code><a title="logger.writers.network_writer.NetworkWriter.input_format" href="writer.html#logger.writers.writer.Writer.input_format">input_format</a></code></li>
<li><code><a title="logger.writers.network_writer.NetworkWriter.write" href="network_writer.html#logger.writers.network_writer.NetworkWriter.write">write</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="logger.writers" href="index.html">logger.writers</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="logger.writers.udp_writer.UDPWriter" href="#logger.writers.udp_writer.UDPWriter">UDPWriter</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.6.3</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>